<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>My Projectss</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="side-menu.css">
  <link rel="stylesheet" href="pure.css">
</head>
<!-- TODO: Add a submenu to make Navigating this long page easier. Or, just put
them all on seperate pages -->
<body>
<div id="layout">
  <!-- Menu toggle -->
  <a href="#menu" id="menuLink" class="menu-link">
      <!-- Hamburger icon -->
      <span></span>
  </a>

  <div id="menu">
    <div class="pure-menu">
      <a class="pure-menu-heading" href="profile.html">James Arnold</a>
      <ul class="pure-menu-list">
        <li class="pure-menu-item"><a href="profile.html" class="pure-menu-link">
        Home</a></li>
        <li class="pure-menu-item"><a href="#" class="pure-menu-link">
        About Me</a></li>
        <li class="pure-menu-item"><a href="my_projects.html" class="pure-menu-link">
        My Projects</a></li>
        <li class="pure-menu-item"><a href="music.html" class="pure-menu-link">
        Music</a></li>
        <li class="pure-menu-item"><a href="#" class="pure-menu-link">
        Contact</a></li>
      </ul>
    </div>
  </div>
  
  <div id="main">
    <div class="header">
      <h1>Completed Projects</h1>
      </div>
      
    <div class="content">     
      <h2>NeZOOMi</h2>
      <h3>Internet-of-things light-following robot for cleaning tubes<h3>
      <h3>Overview</h3>
      <p>My second third-year project was the NeZOOMi Internet-of-things 
      light-following robot. 
      This was an adaptaion of the EEBug (TODO: provide link), to automatically
      follow a light-source using a digital light sensor. This is a prototype of
      a vehicle intended for use in cleaning tubes and tunnels automatically,
      where it can
      be difficult for humans to access. It was controlled by the hugely popular
      Espressif ESP8266 WiFi microtroller, and recieved instructions from a 
      website, which also advertised and described the project. 
      <a href="NeZOOMi/home.html">This website can be viewed here.</a> My role 
      in this project was to create the website and the Python server which 
      processed instructions from the robot, recieved user instructions,
      served the website, and displayed data.</p>
      
      <h3>How it Works</h3>
      <p>The ESP8266 is programmed using the popular <a 
      href="https://micropython.org/">MicroPython</a> microcontroller 
      development platform, which, as the name suggests, allows you to run 
      Python on a microcontroller, rather rather than having to use C/C++ as is       
      customary. Python is far simpler and quicker to program in than C/C++,
      and also reduces the chance of major 
      bugs in the code. The microcontroller collects light level data from an 
      i2c digital lux sensor, and communicats with a PC using the MQTT protocol.
      A Python server running on the PC processes data both from the vehicle 
      and the website. The website backend uses the lovely minimalist web 
      framework <a href="http://bottlepy.org/docs/dev/">Bottle</a> framework 
      to route URLs and process HTTP requests.</p> 
      <p>The website allows the previous 20 light level readins to be displayed
      as a table on the site. It also contains an option to override the default,
      light-following vehicle controls and take manaual control, as can be 
      seen in the video below. The vehicle can now be sterred by the PC's 
      arrow keys.</p>
      
      <h2>Brushless motor controler/Bitcoin hash generator</h2>
      <p>My second 3rd-year project was an embedded systems project to write the
      software for a brushless motor controller. The code needed to be able to 
      make the motor rotate a set number of rotations, which had to be significantly
      accurate. This was set by the user, who could also control the maximum 
      rotational velocity of the motor. Whilst this was going on, the 
      microcontroller also computed bitcoin hashes in the background.</p>
      
      <h3>How it Works</h3>
      <p>The brushless motor works by a series of electromagnets around the motor
      being magnetized in sequence, attracting the magnetic rotor to be attracted
      to them. The position of the rotor was measured using a series of infrared
      LEDs and sensors. The rotor had a large slot in it, so when the slot 
      passed over an LED, the sensor would no longer detect a signal. 
      Using this information to control the motor (a closed-loop feedback system)
      required a strong grasp of control theory, particularly PID control systems, to stop
      the motor ocsillating, or becoming unstable and stuck on maximum speed.</p>
      <p>The microcontroller was a Texas Instruments STM32 chip running on the 
      <a href="https://www.mbed.com/en/">ARM Mbed</a> platform. Running the 
      motor controller and the bictoin hash generator required the use of a 
      real-time operating system, to manage the two taks concurrently in 
      seperate threads. Special code was required to enable threads to communicate
      without blocking the whole program. This can be very important in 
      mission-critical applications. All the code was run in C++, which is very
      common in embedded systems due to its good performance.</p>
      
      
      <h2>KnockLock</h2>
      <p>My 2nd year group project was KnockLock, a knock-pattern door unlocker
      for poeple with hand and arm dexterity problems. When people have these 
      conditions (such as Parkinsons), unlocking a door with a key or using a 
      numeric keypad can become extremely difficult and time-consuming. KockLock
      solves this by using several PiezoElectric sensors (similar a 
      <a href="https://github.com/jamesarnold96/Foam_Drumkit">>MIDI drum kit</a>
      I once built) mounted on a door. These sensors create an electric 
      representation of the vibration of the door. By comparing the intensity of 
      the vibration between the sensors, the approximate location on the door of 
      a knock can be detected. By knocking on the door in a specic pattern, an 
      electric motor is triggered, 
      which unlocks the door. The piezo sensor processing is done by an arduino 
      microcontoller. The piezo circuits improve on the MIDI drumkit by including
      RC filters, which prolong the "peaks" of the signal produced by striking the
      surface. This allows the intensity measurement to be far more accurate, 
      as the sampling frequency of the Arduino is sometimes too low to detected
      particularly short peaks.</p>
      <p>TODO: Find the website</p>
      
      <h2>EEBug</h2>
      <p>My first year university group projct was to design and construct a small 
      line-following robot within a specified time frame and budget. I was the 
      team leader for this project, which provided me with valuable leadership 
      experience and project planning skills. 
      
      
      <h2>MIDI keyboard and scanning matrix tester</h2>
      <p>As you probably have gathered from the rest of this website, I really,
      really like music. Having access to my Dad's old piano completely 
      changed my life. However, most other people are not so priveledged. Even
      today, music can be an often unacceptably expensive field to get into. Indeed,
      owning a piano is still probably one of the most sterotypical signs of
      being middle class. As a challenge, and to aquaint myself with the still
      (at the time) mysterious art of electronics, I decided to build a capable
      electronic keyboard, but making it as cheap as possible.</p>
      <p>To do this, I 
      used a broken Casio SA-46 keyboard I bought off eBay. I completely 
      stripped out the innards and gave it MIDI functionality using a Â£1.50
      Arduino baord. I designed a perfboard layout to make the circuit physically
      compact and robust, so I can add more components when I wish to. I also 
      wrote a scanning keyboard matrix tester to quickly and easily work out 
      which keys map to which microcontroller pin, so conversions like this can
      be carried out far more quickly. All project files, including code and 
      circuit diagrams can be found on my GitHub.</p>
      <h3>Current Status</h3>
      <p>The MIDI decoding and matrix testing code is now written, and the keyboard
      is now a fully functional MIDI controller. In the future, I will add its
      own sound synthesizer, as well as re-adding the original speakers, and 
      appropriate amplification/filter circuits to accompany them. Other things 
      I could add include a screen and various buttons for controlling it. I'll
      probably write a smartphone app to accompany it at some point as well, as
      putting a powerful processor and a large screen in a keyboard seems like a 
      waste of time when everyone already has these things with them in their 
      pockets already.</p>
      
      <h1>Projects in progress</h1>
      
      <h2>2D platform Game</h2>
      <p>Over the past year, I have been part of the Imperial College Game 
      Development society, as part of a project building a 2D Super-Mario-syle
      2D platform game. This is being built using the Unity platform This has 
      helped me significantly develop my programming 
      skills, and gave me the opportunity to learn the C# programming language. 
      The game works by giving the player a deck of cards, which can be used to
      clear levels. There is a great deal of flexibility in how these cards can
      be used, and a lot of the skill involves choosing the correct cards for
      levels, and using them in a creative way.
      <h3>Current Status</h3>
      <p>The first level (the tutorial) of this game is currently playble, with the
      basic character and camera controls working. The card deck system is also
      written, along with "fire" cards, which are able to spawn projectiles. 
      Money and health systems have also been implemented. Once the basic 
      mechanics are implemented, I will start fleshing out the general structure
      of the game. Some ideas I have for it are:
      <ul>
        <li>A highly random approach to elements of the level design and upgrades,
        so part of the skill of playing involves dealing with chance.</li>
        <li>Competetive multiplayer</li>
        <li>"MetroidVania" level style, where there is only one, continuous, large 
        map, rather than several smaller ones.</li>
        <li>Lewis Carroll-style fun, but surreal storyline, exploring the nature 
        of how people view each other.</li>
      </ul>
      </p>
    </div>
  </div>
</div>
</body>
</html>
