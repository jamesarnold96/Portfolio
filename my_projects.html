<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>My Projectss</title>
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" 
  integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" 
  crossorigin="anonymous">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="side-menu.css">
</head>
<!-- TODO: Add a submenu to make Navigating this long page easier. Or, just put
them all on seperate pages -->
<body>
<div id="layout">
  <!-- Menu toggle -->
  <a href="#menu" id="menuLink" class="menu-link">
      <!-- Hamburger icon -->
      <span></span>
  </a>

  <div id="menu">
    <div class="pure-menu">
      <a class="pure-menu-heading" href="#">James Arnold</a>
      <ul class="pure-menu-list">
        <li class="pure-menu-item"><a href="profile.html" class="pure-menu-link">
        Home</a></li>
        <li class="pure-menu-item"><a href="#" class="pure-menu-link">
        About Me</a></li>
        <li class="pure-menu-item"><a href="my_projects.html" class="pure-menu-link">
        My Projects<a/>s</li>
        <li class="pure-menu-item"><a href="music.html" class="pure-menu-link">
        Music</a></li>
        <li class="pure-menu-item"><a href="#" class="pure-menu-link">
        Contact</a></li>
      </ul>
    </div>
  </div>
  
  <div id="main">
    <div class="header">
      <h1>Completed Projects</h1>
      </div>
      
    <div class="content">
      <h2 class="content-subhead">Crack Tracking System</h2>
      <h3>Using Computer vision to automatically measure of the propagation of a crack
      through a composite material.</h3>
      <p>My most recently completed project was my 3rd year university group project.
      This was in association with FAC technology, a composite materials company in 
      Southfields (check), London. The composite materials industry is enjoying 
      phenominal gvrowth at the moment, as these materials are increasing adapted in
      industries such as aerospace as a cheaper alternative to metals such as steel
      and aluminium. However, the process of designing these materials can be very 
      long and expensive, due the large number of tests required for regulatory 
      approval. One of the most important tests is the <em>double cantilever beam test
      (create Wikipedia link)</em>, which uses a machine to apply a force to pull 
      apart a small strip of material. The length of the resulting crack is then
      mesured and recorded, and the graph of force versus displacement can be used 
      to determine various structural properties of the material. This process is 
      currently undertaken by a human observer manually using a microscope, making it 
      a significantly labour-intensive and expensive. </p>
      
      <p>I was part of a team of four who worked to create an automated system for 
      measuring this crack propagation using computer vision. This was done in Python
      using the popular <a href="https://opencv.org/">OpenCV</a> computer vision
      library (provide a link). As can be 
      seen in the video above, 
      TODO: Provide more details.</p>

      <h2>NeZOOMi</h2>
      <h3>Internet-of-things light-following robot for cleaning tubes<h3>
      <h3>Overview</h3>
      <p>My second third-year project was the NeZOOMi Internet-of-things 
      light-following robot. 
      This was an adaptaion of the EEBug (TODO: provide link), to automatically
      follow a light-source using a digital light sensor. This is a prototype of
      a vehicle intended for use in cleaning tubes and tunnels automatically,
      where it can
      be difficult for humans to access. It was controlled by the hugely popular
      Espressif ESP8266 WiFi microtroller, and recieved instructions from a 
      website, which also advertised and described the project. 
      <a href="NeZOOMi/home.html">This website can be viewed here.</a> My role 
      in this project was to create the website and the Python server which 
      processed instructions from the robot, recieved user instructions,
      served the website, and displayed data. 
      </p>
      <h3>How it Works</h3>
      <p>The ESP8266 is programmed using the popular <a 
      href="https://micropython.org/">MicroPython</a> microcontroller development platform, which, 
      as the name suggests, allows you to run Python on a microcontroller, rather 
      rather than having to use C/C++ as is customary. Python is far simpler and
      quicker to program in than C/C++, and also reduces the chance of major 
      bugs in the code. The microcontroller collected light level data from an 
      i2c digital lux sensor, and communicated with a PC using the MQTT
      
      <h2>Brushless motor controler/Bitcoin hash generator</h2>
      
      <h2>KnockLock</h2>
      <p>TODO: Find the website</p>
      
      <h2>EEBug</h2>
      <p>My first year university group projct was to design and construct a small 
      line-following robot within a specified time frame and budget. I was the 
      team leader for this project, which provided me with valuable leadership 
      experience and project planning skills. 
      
      
      <h2>MIDI keyboard and scanning matrix tester</h2>
      <p>As you probably have gathered from the rest of this website, I really,
      really like music. Having access to my Dad's old piano completely 
      changed my life. However, most other people are not so priveledged. Even
      today, music can be an often unacceptably expensive field to get into. Indeed,
      owning a piano is still probably one of the most sterotypical signs of
      being middle class. As a challenge, and to aquaint myself with the still
      (at the time) mysterious art of electronics, I decided to build a capable
      electronic keyboard, but making it as cheap as possible. To do this, I 
      used a broken Casio SA-46 keyboard I bought off eBay. I completely 
      stripped out the innards and gave it MIDI functionality using a Â£1.50
      Arduino baord. I designed a perfboard layout to make the circuit physically
      compact and robust, so I can add more components when I wish to. I also 
      wrote a scanning keyboard matrix tester to quickly and easily work out 
      which keys map to which microcontroller pin, so conversions like this can
      be carried out far more quickly. All project files, including code and 
      circuit diagrams can be found on my GitHub. 
      <h3>Current Status</h3>
      The MIDI decoding and matrix testing code is now written, and the keyboard
      is now a fully functional MIDI controller. In the future, I will add its
      own sound synthesizer, as well as re-adding the original speakers, and 
      appropriate amplification/filter circuits to accompany them. Other things 
      I could add include a screen and various buttons for controlling it. I'll
      probably write a smartphone app to accompany it at some point as well, as
      putting a powerful processor and a large screen in a keyboard seems like a 
      waste of time when everyone already has these things with them in thier 
      pockets already. 
      </p>
      
      <h1>Projects in progress</h1>
      
      <h2>Habitica/Trello task syncing</h2>
      <h3>Using Tasker for Android</h3>
      <p><a href="https://tasker.joaoapps.com/">Tasker</a> is a popular Android
      task automation app, which provides its own JavaScript scripting
      system. I used this to write an app which syncs data between the popular 
      planning and todo apps <a href="https://habitica.com/">Habitica</a> and
      <a href="https://trello.com/">Trello</a>. This is broken up into re-arrangeable
      chunks, which can be used for various tasks by the user. I actually think 
      that this 
      approach can be applied to a wide range of web app types, to reduce our
      unhealthy dependence on external (often large) web service companies like
      Google and Facebook. 
      <h3>Why Habitica?</h3>
      <p>I consider myself unfortunately overburdened with more curiosity than 
      is probably healthy, and often find 
      effective time management difficult. I also struggle with planning and task
      prioritizing. Luckily, I have found salvation in
      the utterly brilliant website and app 
      <a href="https://habitica.com/">Habitica</a>, which 
      turns task management into an RPG game, making the whole process much more
      fun and useful, and makes me far more productive (as a side note, it is
      similar to a somewhat cruder text game I created in high school). It 
      provides health and xp systems for when I've completed/failed tasks,
      as well as a neat and flexible reward system.</p>
      <h3>Why Trello?</h3>
      <p>Another task-management website I struggle to live without is the
      also brilliant <a href="https://trello.com/">Trello</a>, which is very 
      common for organizing group projects. If you haven't seen it already, it 
      displays tasks using a pinboard-style layout, which allows tasks ("cards")
      to be grouped by category. A user can also have multiple boards. This 
      visual style is extremely useful for project planning and organizing tasks.</p>
      <h3>The Syncing Dillema</h3>
      <p>Both of these services are very good for different purposes, Trello for
      its pinboard interface, and Habitica for its scoring, reward and social 
      systems. However, there is currently no way of syncing tasks between these
      services that I am aware of. The 
      <a href="https://github.com/DC23/scriptabit">only one I could find</a> 
      didn't work properly for me. Luckily, both services provide HTTP APIs, so
      it is possible to create a 
      web app to do the task syncing relatively easily. Common apps for this
      kind of thing like IFTTT don't work for this case.</p>
      <h3>Enter Tasker</h3>
      <p>To implement this, I took the somewhat unusual step of using the Android
      automation app <a href="https://tasker.joaoapps.com/">Tasker</a>. This was beacuse most people have 
      a smartphone nowadays, which is connected to the internet most of the time. 
      This allows it to periodically sync tasks in a way a PC cannot, and be 
      scheduled to do so at specific times. Importantly, Tasker is also straightforward
      for non-programmers to use, so using this would allow these people to 
      customize it to their liking. To make development easier, I also created a simple
      Python web server using the <a href="http://bottlepy.org/docs/dev/">Bottle 
      library</a>, which allows Tasker routines to be tested on a PC, 
      substatially speeding up the development and debugging process.</p>
      <h3>Current Status</h3>
      <p>The functions for getting the task data from the internet are complete,
      as is the test site and server. The actual syncing code, along with code 
      to upload the new data to the websites, is still in progress.</p>
      
      <h2>2D platform Game</h2>
      <p>Over the past year, I have been part of the Imperial College Game 
      Development society, as part of a project building a 2D Super-Mario-syle
      2D platform game. This is being built using the Unity platform This has 
      helped me significantly develop my programming 
      skills, and gave me the opportunity to learn the C# programming language. 
      The game works by giving the player a deck of cards, which can be used to
      clear levels. There is a great deal of flexibility in how these cards can
      be used, and a lot of the skill involves choosing the correct cards for
      levels, and using them in a creative way.
      <h3>Current Status</h3>
      The first level (the tutorial) of this game is currently playble, with the
      basic character and camera controls working. The card deck system is also
      written, along with "fire" cards, which are able to spawn projectiles. 
      Money and health systems have also been implemented. 
    </div>
  </div>
</div>
</body>
</html>
