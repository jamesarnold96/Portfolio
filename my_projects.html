<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>My Projectss</title>
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" 
  integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" 
  crossorigin="anonymous">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="side-menu.css">
</head>
<!-- TODO: Add a submenu to make Navigating this long page easier. Or, just put
them all on seperate pages -->
<body>
<div id="layout">
  <!-- Menu toggle -->
  <a href="#menu" id="menuLink" class="menu-link">
      <!-- Hamburger icon -->
      <span></span>
  </a>

  <div id="menu">
    <div class="pure-menu">
      <a class="pure-menu-heading" href="profile.html">James Arnold</a>
      <ul class="pure-menu-list">
        <li class="pure-menu-item"><a href="profile.html" class="pure-menu-link">
        Home</a></li>
        <li class="pure-menu-item"><a href="#" class="pure-menu-link">
        About Me</a></li>
        <li class="pure-menu-item"><a href="my_projects.html" class="pure-menu-link">
        My Projects<a/>s</li>
        <li class="pure-menu-item"><a href="music.html" class="pure-menu-link">
        Music</a></li>
        <li class="pure-menu-item"><a href="#" class="pure-menu-link">
        Contact</a></li>
      </ul>
    </div>
  </div>
  
  <div id="main">
    <div class="header">
      <h1>Completed Projects</h1>
      </div>
      
    <div class="content">     
      <h2>NeZOOMi</h2>
      <h3>Internet-of-things light-following robot for cleaning tubes<h3>
      <h3>Overview</h3>
      <p>My second third-year project was the NeZOOMi Internet-of-things 
      light-following robot. 
      This was an adaptaion of the EEBug (TODO: provide link), to automatically
      follow a light-source using a digital light sensor. This is a prototype of
      a vehicle intended for use in cleaning tubes and tunnels automatically,
      where it can
      be difficult for humans to access. It was controlled by the hugely popular
      Espressif ESP8266 WiFi microtroller, and recieved instructions from a 
      website, which also advertised and described the project. 
      <a href="NeZOOMi/home.html">This website can be viewed here.</a> My role 
      in this project was to create the website and the Python server which 
      processed instructions from the robot, recieved user instructions,
      served the website, and displayed data.</p>
      
      <h3>How it Works</h3>
      <p>The ESP8266 is programmed using the popular <a 
      href="https://micropython.org/">MicroPython</a> microcontroller 
      development platform, which, as the name suggests, allows you to run 
      Python on a microcontroller, rather rather than having to use C/C++ as is       
      customary. Python is far simpler and quicker to program in than C/C++,
      and also reduces the chance of major 
      bugs in the code. The microcontroller collects light level data from an 
      i2c digital lux sensor, and communicats with a PC using the MQTT protocol.
      A Python server running on the PC processes data both from the vehicle 
      and the website. The website backend uses the lovely minimalist web 
      framework <a href="http://bottlepy.org/docs/dev/">Bottle</a> framework 
      to route URLs and process HTTP requests.</p> 
      <p>The website allows the previous 20 light level readins to be displayed
      as a table on the site. It also contains an option to override the default,
      light-following vehicle controls and take manaual control, as can be 
      seen in the video below. The vehicle can now be sterred by the PC's 
      arrow keys.</p>
      
      <h2>Brushless motor controler/Bitcoin hash generator</h2>
      
      <h2>KnockLock</h2>
      <p>My 2nd year group project was KnockLock, a knock-pattern door unlocker
      for poeple with hand and arm dexterity problems. When people have these 
      conditions (such as Parkinsons), unlocking a door with a key or using a 
      numeric keypad can become extremely difficult and time-consuming. KockLock
      solves this by using several PiezoElectric sensors (similar a 
      <a href="https://github.com/jamesarnold96/Foam_Drumkit">>MIDI drum kit</a>
      I once built) mounted on a door. These sensors create an electric 
      representation of the vibration of the door. By comparing the intensity of 
      the vibration between the sensors, the approximate location on the door of 
      a knock can be detected. By knocking on the door in a specic pattern, an 
      electric motor is triggered, 
      which unlocks the door. The piezo sensor processing is done by an arduino 
      microcontoller. The piezo circuits improve on the MIDI drumkit by including
      RC filters, which prolong the "peaks" of the signal produced by striking the
      surface. This allows the intensity measurement to be far more accurate, 
      as the sampling frequency of the Arduino is sometimes too low to detected
      particularly short peaks.</p>
      <p>TODO: Find the website</p>
      
      <h2>EEBug</h2>
      <p>My first year university group projct was to design and construct a small 
      line-following robot within a specified time frame and budget. I was the 
      team leader for this project, which provided me with valuable leadership 
      experience and project planning skills. 
      
      
      <h2>MIDI keyboard and scanning matrix tester</h2>
      <p>As you probably have gathered from the rest of this website, I really,
      really like music. Having access to my Dad's old piano completely 
      changed my life. However, most other people are not so priveledged. Even
      today, music can be an often unacceptably expensive field to get into. Indeed,
      owning a piano is still probably one of the most sterotypical signs of
      being middle class. As a challenge, and to aquaint myself with the still
      (at the time) mysterious art of electronics, I decided to build a capable
      electronic keyboard, but making it as cheap as possible.</p>
      <p>To do this, I 
      used a broken Casio SA-46 keyboard I bought off eBay. I completely 
      stripped out the innards and gave it MIDI functionality using a Â£1.50
      Arduino baord. I designed a perfboard layout to make the circuit physically
      compact and robust, so I can add more components when I wish to. I also 
      wrote a scanning keyboard matrix tester to quickly and easily work out 
      which keys map to which microcontroller pin, so conversions like this can
      be carried out far more quickly. All project files, including code and 
      circuit diagrams can be found on my GitHub.</p>
      <h3>Current Status</h3>
      <p>The MIDI decoding and matrix testing code is now written, and the keyboard
      is now a fully functional MIDI controller. In the future, I will add its
      own sound synthesizer, as well as re-adding the original speakers, and 
      appropriate amplification/filter circuits to accompany them. Other things 
      I could add include a screen and various buttons for controlling it. I'll
      probably write a smartphone app to accompany it at some point as well, as
      putting a powerful processor and a large screen in a keyboard seems like a 
      waste of time when everyone already has these things with them in their 
      pockets already.</p>
      
      <h1>Projects in progress</h1>
      
      <h2>Habitica/Trello task syncing</h2>
      <h3>Using Tasker for Android</h3>
      <p><a href="https://tasker.joaoapps.com/">Tasker</a> is a popular Android
      task automation app, which provides its own JavaScript scripting
      system. I used this to write an app which syncs data between the popular 
      planning and todo apps <a href="https://habitica.com/">Habitica</a> and
      <a href="https://trello.com/">Trello</a>. This is broken up into re-arrangeable
      chunks, which can be used for various tasks by the user. I actually think 
      that this 
      approach can be applied to a wide range of web app types, to reduce our
      unhealthy dependence on external (often large) web service companies like
      Google and Facebook. 
      <h3>Why Habitica?</h3>
      <p>I consider myself unfortunately overburdened with more curiosity than 
      is probably healthy, and often find 
      effective time management difficult. I also struggle with planning and task
      prioritizing. Luckily, I have found salvation in
      the utterly brilliant website and app 
      <a href="https://habitica.com/">Habitica</a>, which 
      turns task management into an RPG game, making the whole process much more
      fun and useful, and makes me far more productive (as a side note, it is
      similar to a somewhat cruder text game I created in high school). It 
      provides health and xp systems for when I've completed/failed tasks,
      as well as a neat and flexible reward system.</p>
      <h3>Why Trello?</h3>
      <p>Another task-management website I struggle to live without is the
      also brilliant <a href="https://trello.com/">Trello</a>, which is very 
      common for organizing group projects. If you haven't seen it already, it 
      displays tasks using a pinboard-style layout, which allows tasks ("cards")
      to be grouped by category. A user can also have multiple boards. This 
      visual style is extremely useful for project planning and organizing tasks.</p>
      <h3>The Syncing Dillema</h3>
      <p>Both of these services are very good for different purposes, Trello for
      its pinboard interface, and Habitica for its scoring, reward and social 
      systems. However, there is currently no way of syncing tasks between these
      services that I am aware of. The 
      <a href="https://github.com/DC23/scriptabit">only one I could find</a> 
      didn't work properly for me. Luckily, both services provide HTTP APIs, so
      it is possible to create a 
      web app to do the task syncing relatively easily. Common apps for this
      kind of thing like IFTTT don't work for this case.</p>
      <h3>Enter Tasker</h3>
      <p>To implement this, I took the somewhat unusual step of using the Android
      automation app <a href="https://tasker.joaoapps.com/">Tasker</a>. This was beacuse most people have 
      a smartphone nowadays, which is connected to the internet most of the time. 
      This allows it to periodically sync tasks in a way a PC cannot, and be 
      scheduled to do so at specific times. Importantly, Tasker is also straightforward
      for non-programmers to use, so using this would allow these people to 
      customize it to their liking. To make development easier, I also created a simple
      Python web server using the <a href="http://bottlepy.org/docs/dev/">Bottle 
      library</a>, which allows Tasker routines to be tested on a PC, 
      substatially speeding up the development and debugging process.</p>
      <h3>Current Status</h3>
      <p>The functions for getting the task data from the internet are complete,
      as is the test site and server. The actual syncing code, along with code 
      to upload the new data to the websites, is still in progress.</p>
      
      <h2>2D platform Game</h2>
      <p>Over the past year, I have been part of the Imperial College Game 
      Development society, as part of a project building a 2D Super-Mario-syle
      2D platform game. This is being built using the Unity platform This has 
      helped me significantly develop my programming 
      skills, and gave me the opportunity to learn the C# programming language. 
      The game works by giving the player a deck of cards, which can be used to
      clear levels. There is a great deal of flexibility in how these cards can
      be used, and a lot of the skill involves choosing the correct cards for
      levels, and using them in a creative way.
      <h3>Current Status</h3>
      <p>The first level (the tutorial) of this game is currently playble, with the
      basic character and camera controls working. The card deck system is also
      written, along with "fire" cards, which are able to spawn projectiles. 
      Money and health systems have also been implemented. Once the basic 
      mechanics are implemented, I will start fleshing out the general structure
      of the game. Some ideas I have for it are:
      <ul>
        <li>A highly random approach to elements of the level design and upgrades,
        so part of the skill of playing involves dealing with chance.</li>
        <li>Competetive multiplayer</li>
        <li>"MetroidVania" level style, where there is only one, continuous, large 
        map, rather than several smaller ones.</li>
        <li>Lewis Carroll-style fun, but surreal storyline, exploring the nature 
        of how people view each other.</li>
      </ul>
      </p>
    </div>
  </div>
</div>
</body>
</html>
